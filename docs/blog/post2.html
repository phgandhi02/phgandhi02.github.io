<!DOCTYPE html>
<html>
  <head>
    <title>Blog - Prem Gandhi's Personal Website</title>
    <link href="../css/styles.css" rel="stylesheet" />
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">
        <span class="d-block d-lg-none">Prem Gandhi</span>
        <span class="d-none d-lg-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="../prem-gandhi-laboratory-1080x1080-72dpi-01.jpg" alt="picture of Prem Gandhi" /></span>
      </a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav">
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../index.html">About</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../porfolio.html">Portfolio</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="blogMainPage.html">Blog</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../pictures.html">Pictures</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../404.html">Interests</a></li>
          <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../404.html">Awards</a></li>
        </ul>
      </div>
    </nav>
    <div class="container">
      <h1 id="reproducibility-and-the-modern-python-development-environment-essay">Reproducibility and the Modern Python Development Environment Essay</h1>
      <h2 id="goal-">Goal:</h2>
      <p>The goal of this essay is to enable the reader to be able to establish a baseline understanding as to code reproducibility in programming and the necessity for creating environments that can be deployed on any platform that may be included in the deployment audience. Additionally, this essays covers the use of tools designed for creating elegant and professional looking code that can be easily transferred from drawing to code and tested to meet performance criteria. This essay is a basic introduction into the principles that guide modern development with an implementation in the Python language. An effort will be make to ensure that this can be applied to other languages when possible. </p>
      <h2 id="assumptions-that-i-need-to-address-">Assumptions that I need to address:</h2>
      <ol>
      <li>OS principles:<ol>
      <li>Unix style file directory</li>
      <li>OS processes<ol>
      <li>How is the computer broken down: 
      The computer is broken down into a kernel that connects the hardware with the applications and services that you want to run. The following picture illustrates the point: !Pasted image 20240126155000.png
      We see that the hardware is all connected to the kernel, in this case Linux kernel, and it will make sure that all the services inside and above can talk to the list of daemons, shells, toolkits, etc. can have resources. Think of it like a broker service.</li>
      </ol>
      </li>
      </ol>
      </li>
      <li>what problems do people run in implementation: <pre><code> <span class="hljs-number">1.</span> code reproducibility: someone tries <span class="hljs-keyword">to</span> hand another person code <span class="hljs-keyword">and</span> they are <span class="hljs-keyword">not</span> able <span class="hljs-keyword">to</span> <span class="hljs-keyword">set</span> your computer up like theirs
          <span class="hljs-number">1.</span> dependencies: Your code may involve using lots <span class="hljs-keyword">of</span> packages <span class="hljs-keyword">and</span> linked files <span class="hljs-keyword">to</span> <span class="hljs-built_in">run</span>, especially <span class="hljs-keyword">in</span> cases <span class="hljs-keyword">of</span> machine learning <span class="hljs-keyword">where</span> CUDA support <span class="hljs-keyword">is</span> crucial. 
              <span class="hljs-number">1.</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">for</span> dependencies <span class="hljs-keyword">is</span> a crucial thing <span class="hljs-keyword">that</span> oftentimes becomes a problem <span class="hljs-keyword">as</span> code <span class="hljs-keyword">is</span> updated <span class="hljs-keyword">over</span> <span class="hljs-built_in">time</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> need <span class="hljs-keyword">for</span> support <span class="hljs-keyword">on</span> various platforms <span class="hljs-keyword">or</span> compatibility <span class="hljs-keyword">with</span> different packages becomes important. 
              <span class="hljs-number">2.</span> environment variable: one person's computer may have environment variables <span class="hljs-keyword">that</span> you don't have so <span class="hljs-keyword">if</span> you can recreate <span class="hljs-keyword">the</span> environment <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> variables used <span class="hljs-keyword">then</span> this makes <span class="hljs-keyword">it</span> easy <span class="hljs-keyword">to</span> replicate. 
              <span class="hljs-number">3.</span> <span class="hljs-built_in">file</span> directory setup: one person's <span class="hljs-built_in">file</span> directory system may be setup differently than another person's directory therefore we would like <span class="hljs-keyword">to</span> have a standardized framework <span class="hljs-keyword">that</span> we can use. This enables your code <span class="hljs-keyword">to</span> work <span class="hljs-keyword">with</span> code <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> other parts <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> computer. Consider <span class="hljs-keyword">the</span> fact <span class="hljs-keyword">that</span> we may <span class="hljs-keyword">not</span> know <span class="hljs-keyword">where</span> <span class="hljs-keyword">the</span> files are placed. By ensuring <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> same place <span class="hljs-keyword">for</span> everyone <span class="hljs-keyword">then</span> we can may development easier. 
      <span class="hljs-number">2.</span> Code Maintenance
          <span class="hljs-number">1.</span> Code Abstraction:
              <span class="hljs-number">1.</span> Code Modularity: This means <span class="hljs-keyword">that</span> whenever a <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> code <span class="hljs-keyword">does</span> <span class="hljs-keyword">some</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> commands <span class="hljs-keyword">then</span> <span class="hljs-keyword">it</span> should be turned <span class="hljs-keyword">into</span> a function. That function can <span class="hljs-keyword">then</span> placed <span class="hljs-keyword">into</span> larger functions such <span class="hljs-keyword">that</span> a more complex feature <span class="hljs-keyword">is</span> executed. Another approach <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> use <span class="hljs-built_in">class</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> attach methods so <span class="hljs-keyword">that</span> <span class="hljs-keyword">if</span> you have a <span class="hljs-built_in">class</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">it</span> will <span class="hljs-keyword">contain</span> all <span class="hljs-keyword">the</span> stuff <span class="hljs-keyword">it</span> needs <span class="hljs-keyword">to</span> operate. Have a <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> classes <span class="hljs-keyword">then</span> you can <span class="hljs-keyword">put</span> them together <span class="hljs-keyword">into</span> a larger <span class="hljs-built_in">class</span> <span class="hljs-keyword">that</span> will <span class="hljs-keyword">contain</span> all those functions <span class="hljs-keyword">and</span> whatever <span class="hljs-keyword">else</span> <span class="hljs-keyword">it</span> needs. Code Modularity functions such <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> allows you <span class="hljs-keyword">to</span> tuck away <span class="hljs-keyword">the</span> details <span class="hljs-keyword">and</span> trust <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> solution works when you apply <span class="hljs-keyword">it</span>. Then <span class="hljs-keyword">the</span> only work <span class="hljs-keyword">is</span> <span class="hljs-keyword">about</span> how you use your newly made tool.
              Try <span class="hljs-keyword">to</span> develop abstract representations <span class="hljs-keyword">of</span> your code such <span class="hljs-keyword">as</span> putting a <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> commands <span class="hljs-keyword">into</span> a function, <span class="hljs-built_in">class</span>, <span class="hljs-keyword">or</span> <span class="hljs-keyword">script</span>.
          <span class="hljs-number">1.</span> Refactor code: Refactoring code <span class="hljs-keyword">is</span> an important job <span class="hljs-keyword">that</span> can sometimes <span class="hljs-keyword">get</span> left under <span class="hljs-keyword">the</span> rug. It simply means cleaning up <span class="hljs-keyword">the</span> code <span class="hljs-keyword">that</span> you've written <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> simple, professional, <span class="hljs-keyword">and</span> elegant. This may involve taking a less optimized approach <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> more understand <span class="hljs-keyword">and</span> more flexible <span class="hljs-keyword">while</span> understanding <span class="hljs-keyword">the</span> limitations <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> code. 
          <span class="hljs-number">2.</span> code testing: this <span class="hljs-keyword">is</span> when you implement tests/logic <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> your code <span class="hljs-keyword">is</span> robust <span class="hljs-keyword">and</span> you can figure out what went wrong <span class="hljs-keyword">if</span> your code doesn't work right. This solves a reproducibility problem <span class="hljs-keyword">by</span> giving diagnostics <span class="hljs-keyword">about</span> what failed <span class="hljs-keyword">and</span> why when you test a software <span class="hljs-built_in">application</span>. 
              <span class="hljs-number">1.</span>  unit testing: This <span class="hljs-keyword">is</span> a specific tool <span class="hljs-keyword">that</span> has been transformed <span class="hljs-keyword">into</span> a methodology called Test-Driven Development. The idea <span class="hljs-keyword">is</span> <span class="hljs-keyword">that</span> you can create simple tests <span class="hljs-keyword">that</span> will <span class="hljs-keyword">tell</span> you <span class="hljs-keyword">if</span> your code <span class="hljs-keyword">is</span> operating <span class="hljs-keyword">the</span> way you want <span class="hljs-keyword">by</span> seeing <span class="hljs-keyword">if</span> <span class="hljs-keyword">the</span> results you pass are <span class="hljs-keyword">as</span> expected <span class="hljs-keyword">or</span> <span class="hljs-keyword">if</span> they are different. This <span class="hljs-keyword">is</span> useful when your code has bugs <span class="hljs-keyword">that</span> don't <span class="hljs-literal">result</span> <span class="hljs-keyword">in</span> errors so you <span class="hljs-keyword">end</span> up <span class="hljs-keyword">with</span> a software <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> telling you <span class="hljs-literal">false</span> information <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> assumed <span class="hljs-keyword">to</span> be right. 
                  `X = <span class="hljs-number">1</span>`
                  `y = x + x`
                  `y = <span class="hljs-number">1000</span>
              <span class="hljs-number">2.</span> integration testing: This helps <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> when various pieces <span class="hljs-keyword">of</span> code, imported modules, <span class="hljs-keyword">and</span> called services all work together <span class="hljs-keyword">as</span> expected. Note <span class="hljs-keyword">that</span> pieces <span class="hljs-keyword">of</span> code, modules, <span class="hljs-keyword">and</span> services can operate <span class="hljs-keyword">without</span> <span class="hljs-keyword">error</span> <span class="hljs-keyword">while</span> still delivering faulty, buggy results. These are more computer intensive than unit tests <span class="hljs-keyword">since</span> <span class="hljs-keyword">it</span> means <span class="hljs-keyword">that</span> various parts <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> code will be initialized <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> tested. This <span class="hljs-keyword">is</span> crucial <span class="hljs-keyword">for</span> making sure <span class="hljs-keyword">that</span> your code works <span class="hljs-keyword">the</span> way <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> supposed <span class="hljs-keyword">to</span> <span class="hljs-keyword">with</span> other code. This only tests whether <span class="hljs-keyword">the</span> pieces work together <span class="hljs-keyword">not</span> <span class="hljs-keyword">if</span> they work together well.
              <span class="hljs-number">3.</span> Functional testing: this <span class="hljs-keyword">is</span> testing <span class="hljs-keyword">to</span> focus <span class="hljs-keyword">on</span> how <span class="hljs-keyword">the</span> software accomplishes <span class="hljs-keyword">the</span> business requirements <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> was designed <span class="hljs-keyword">to</span> accomplish. If a search app was designed <span class="hljs-keyword">then</span> this kind <span class="hljs-keyword">of</span> testing determine whether people can effectively search <span class="hljs-keyword">from</span> a business <span class="hljs-keyword">or</span> use perspective <span class="hljs-keyword">to</span> accomplish <span class="hljs-keyword">the</span> requirement <span class="hljs-keyword">of</span> enabling people <span class="hljs-keyword">to</span> search effectively. This tests <span class="hljs-keyword">to</span> see <span class="hljs-keyword">if</span> pieces work together well <span class="hljs-keyword">and</span> correctly. 
              <span class="hljs-number">4.</span> End-<span class="hljs-keyword">to</span>-<span class="hljs-keyword">end</span> testing: This <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> test specific use cases <span class="hljs-keyword">that</span> would imitate a user trying <span class="hljs-keyword">to</span> perform <span class="hljs-keyword">some</span> action <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> often more complex than simply testing functionality. These kinds <span class="hljs-keyword">of</span> tests are useful <span class="hljs-keyword">but</span> hard <span class="hljs-keyword">to</span> maintain <span class="hljs-keyword">and</span> should <span class="hljs-keyword">not</span> be relied <span class="hljs-keyword">on</span> <span class="hljs-keyword">since</span> this changes often <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> hard <span class="hljs-keyword">to</span> develop <span class="hljs-keyword">without</span> existing test infrastructure. 
      <span class="hljs-number">3.</span> Code communication: when more than one person <span class="hljs-keyword">is</span> working <span class="hljs-keyword">on</span> code <span class="hljs-keyword">then</span> how do you make sure <span class="hljs-keyword">that</span> your change won't screw up <span class="hljs-keyword">the</span> codebase. Consider <span class="hljs-keyword">the</span> fact <span class="hljs-keyword">that</span> multiple people may be working <span class="hljs-keyword">on</span> different functions <span class="hljs-keyword">that</span> are going <span class="hljs-keyword">to</span> placed <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> same document. How can you make sure <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> solution <span class="hljs-keyword">that</span> you've made still works? By using source control <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> control like Github, we can solve this problem.
          <span class="hljs-number">1.</span> source control: source control <span class="hljs-keyword">is</span> important <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> foundation multiple people are building <span class="hljs-keyword">on</span> stays <span class="hljs-keyword">the</span> same. Consider a team <span class="hljs-keyword">of</span> architects decides <span class="hljs-keyword">to</span> work <span class="hljs-keyword">with</span> contractors <span class="hljs-keyword">to</span> build a house. If one architect goes <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">middle</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> night <span class="hljs-keyword">and</span> changes <span class="hljs-keyword">the</span> plans <span class="hljs-keyword">then</span> this may affect whether <span class="hljs-keyword">the</span> solutions <span class="hljs-keyword">that</span> other architects made will apply. Additionally, <span class="hljs-keyword">the</span> contractors will have <span class="hljs-keyword">to</span> completely redo their work <span class="hljs-keyword">since</span> their solution may no longer be valid. If changes are understood <span class="hljs-keyword">and</span> agreed upon <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> entire team <span class="hljs-keyword">then</span> this problem can be averted. This <span class="hljs-keyword">is</span> done <span class="hljs-keyword">by</span> having people <span class="hljs-keyword">get</span> copies <span class="hljs-keyword">of</span> an agreed upon assumption/framework <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> putting their solution <span class="hljs-keyword">on</span> top. The various solutions are combined <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> any errors <span class="hljs-keyword">that</span> <span class="hljs-literal">result</span> can be resolved though this should be minimal <span class="hljs-keyword">in</span> an ideal case.
          <span class="hljs-number">2.</span> versioning: People may <span class="hljs-keyword">not</span> know what <span class="hljs-keyword">the</span> latest code <span class="hljs-keyword">is</span>. By implementing a versioning tool, people can ensure <span class="hljs-keyword">that</span> they have <span class="hljs-keyword">the</span> latest setup <span class="hljs-keyword">and</span> along <span class="hljs-keyword">with</span> knowing how changes were implemented <span class="hljs-keyword">over</span> various iterations. 
      <span class="hljs-number">4.</span> code comprehension:
          People often jump <span class="hljs-keyword">to</span> asking ChatGPT <span class="hljs-keyword">or</span> searching Stack Overflow <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> answer rather than deducing <span class="hljs-keyword">the</span> answer <span class="hljs-keyword">on</span> their own. This can save <span class="hljs-built_in">time</span> <span class="hljs-keyword">but</span> <span class="hljs-keyword">it</span> comes <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> expense <span class="hljs-keyword">of</span> understanding <span class="hljs-keyword">and</span> exercise <span class="hljs-keyword">of</span> intellectual faculties which need <span class="hljs-keyword">to</span> be tested <span class="hljs-keyword">and</span> stressed constantly so <span class="hljs-keyword">that</span> we can grow. 
          <span class="hljs-number">1.</span> documentation: this <span class="hljs-keyword">is</span> crucial <span class="hljs-keyword">for</span> making sure <span class="hljs-keyword">that</span> people can understand your code <span class="hljs-keyword">if</span> they want <span class="hljs-keyword">to</span> go <span class="hljs-keyword">back</span> <span class="hljs-keyword">and</span> understand. Good code <span class="hljs-keyword">is</span> something <span class="hljs-keyword">that</span> people love <span class="hljs-keyword">to</span> go <span class="hljs-keyword">back</span> <span class="hljs-keyword">and</span> use, including yourself. Consider <span class="hljs-keyword">the</span> library OpenCV which has a famously amazing documentation which can walk anyone <span class="hljs-keyword">through</span> how <span class="hljs-keyword">to</span> do object recognition.
              <span class="hljs-number">1.</span> one-liner documentation: This <span class="hljs-keyword">is</span> when you just <span class="hljs-keyword">put</span> small comments next <span class="hljs-keyword">to</span> your statements <span class="hljs-keyword">to</span> help elucidate what <span class="hljs-keyword">the</span> goal <span class="hljs-keyword">of</span> your command <span class="hljs-keyword">is</span>. This can help you think <span class="hljs-keyword">through</span> what you want <span class="hljs-keyword">to</span> do along <span class="hljs-keyword">with</span> guiding others.
              <span class="hljs-number">2.</span> function-level documentation: This <span class="hljs-keyword">is</span> documentation <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> placed <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> top <span class="hljs-keyword">of</span> a series <span class="hljs-keyword">of</span> one-liners. It explains what <span class="hljs-keyword">the</span> overall goal <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> following commands <span class="hljs-keyword">is</span> <span class="hljs-keyword">as</span> well <span class="hljs-keyword">as</span> how <span class="hljs-keyword">to</span> use <span class="hljs-keyword">the</span> function. The function can be implemented <span class="hljs-keyword">as</span> a one-liner documentation  so we want <span class="hljs-keyword">to</span> understand how <span class="hljs-keyword">to</span> use <span class="hljs-keyword">the</span> function easily <span class="hljs-keyword">but</span> don't want <span class="hljs-keyword">to</span> <span class="hljs-built_in">read</span> <span class="hljs-keyword">through</span> <span class="hljs-keyword">the</span> details <span class="hljs-keyword">of</span> what happens. 
              <span class="hljs-number">3.</span> <span class="hljs-built_in">class</span>-level documentation: This <span class="hljs-keyword">is</span> documentation <span class="hljs-keyword">that</span> explains what <span class="hljs-keyword">the</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> functions/methods <span class="hljs-keyword">is</span> designed <span class="hljs-keyword">to</span> do <span class="hljs-keyword">and</span> what <span class="hljs-keyword">the</span> goal <span class="hljs-keyword">of</span> this collection <span class="hljs-keyword">of</span> functions/methods <span class="hljs-keyword">is</span>. It also explains what <span class="hljs-keyword">the</span> initialization <span class="hljs-keyword">of</span> this <span class="hljs-built_in">class</span> <span class="hljs-keyword">does</span> <span class="hljs-keyword">and</span> how <span class="hljs-keyword">to</span> use <span class="hljs-keyword">it</span>. This should be a higher level description than a compilation <span class="hljs-keyword">of</span> function-level documentation. It should explain how <span class="hljs-keyword">to</span> use <span class="hljs-keyword">the</span> <span class="hljs-built_in">class</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> available functions <span class="hljs-keyword">with</span> brief descriptions <span class="hljs-keyword">of</span> what they are <span class="hljs-keyword">for</span> <span class="hljs-keyword">and</span> how <span class="hljs-keyword">to</span> use them.
              <span class="hljs-number">4.</span> <span class="hljs-keyword">script</span>-level documentation: This <span class="hljs-keyword">is</span> documentation <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> designed <span class="hljs-keyword">to</span> explain what <span class="hljs-keyword">the</span> point <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">script</span>/library <span class="hljs-keyword">is</span>. This <span class="hljs-keyword">is</span> a high level view <span class="hljs-keyword">of</span> what <span class="hljs-keyword">the</span> code module <span class="hljs-keyword">does</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> explains any classes, <span class="hljs-keyword">script</span>-level functions, <span class="hljs-keyword">and</span> <span class="hljs-keyword">script</span>-wide parameters. This allows someone who calls <span class="hljs-keyword">the</span> module <span class="hljs-keyword">into</span> another document <span class="hljs-keyword">to</span> understand what functionality they can gain <span class="hljs-keyword">and</span> what tools are available <span class="hljs-keyword">to</span> do so. This can be something <span class="hljs-keyword">with</span> a summary followed <span class="hljs-keyword">by</span> a fairly lengthy detailed description <span class="hljs-keyword">that</span> shows what <span class="hljs-keyword">the</span> code can do <span class="hljs-keyword">on</span> a functional, goal-oriented level.
          <span class="hljs-number">2.</span> reasoning: This means applying logic <span class="hljs-keyword">and</span> understanding <span class="hljs-keyword">the</span> cognitive train <span class="hljs-keyword">of</span> thought <span class="hljs-keyword">that</span> <span class="hljs-keyword">it</span> involved <span class="hljs-keyword">with</span> getting <span class="hljs-keyword">from</span> one <span class="hljs-keyword">set</span> <span class="hljs-keyword">of</span> information <span class="hljs-keyword">or</span> assumptions <span class="hljs-keyword">to</span> a conclusion. Reasoning often occurs <span class="hljs-keyword">in</span> a passive sense <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> something <span class="hljs-keyword">that</span> we do fast-thinking; however, something reasoning involves slow-thinking. We can use models <span class="hljs-keyword">to</span> simplify <span class="hljs-keyword">the</span> logical sequence <span class="hljs-keyword">of</span> steps <span class="hljs-keyword">that</span> must be taken <span class="hljs-keyword">to</span> understand a conclusion. This <span class="hljs-keyword">is</span> often expensive <span class="hljs-keyword">to</span> do <span class="hljs-keyword">in</span> reality <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> may <span class="hljs-keyword">not</span> be feasible <span class="hljs-keyword">with</span> additional <span class="hljs-built_in">time</span> <span class="hljs-keyword">or</span> cognitive constraints.
          <span class="hljs-number">3.</span> Observation/contemplation: This <span class="hljs-keyword">is</span> when we simply see <span class="hljs-keyword">the</span> code <span class="hljs-built_in">running</span> <span class="hljs-keyword">and</span> we look <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> outputs <span class="hljs-keyword">and</span> see what happens when <span class="hljs-keyword">the</span> program <span class="hljs-keyword">is</span> <span class="hljs-built_in">run</span>. 
              The use <span class="hljs-keyword">of</span> observation allows us <span class="hljs-keyword">to</span> gain knowledge <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> experts have <span class="hljs-keyword">and</span> use, <span class="hljs-keyword">but</span> are unable <span class="hljs-keyword">to</span> convey <span class="hljs-keyword">as</span> a <span class="hljs-literal">result</span> <span class="hljs-keyword">of</span> hidden assumptions. Exposing these hidden assumptions consciously takes a lot <span class="hljs-keyword">of</span> work <span class="hljs-keyword">and</span> therefore <span class="hljs-keyword">it</span> may be easier <span class="hljs-keyword">to</span> implement a habit <span class="hljs-keyword">of</span> observation. This <span class="hljs-keyword">is</span> what happens <span class="hljs-keyword">in</span> art.
              !Pasted image <span class="hljs-number">20240201000003.</span>png
          <span class="hljs-number">4.</span> Appeal <span class="hljs-keyword">to</span> Authority: This <span class="hljs-keyword">is</span> when you consult a trusted person <span class="hljs-keyword">or</span> resource like Stack Overflow <span class="hljs-keyword">to</span> determine what <span class="hljs-keyword">is</span> happening. This can also be <span class="hljs-keyword">through</span> reading <span class="hljs-keyword">through</span> <span class="hljs-keyword">the</span> documentation <span class="hljs-keyword">for</span> any functions which <span class="hljs-keyword">is</span> almost always available. 
      </code></pre></li>
      <li>what do tools do people normally use when developing code:<pre><code>     <span class="hljs-number">1.</span> code reproducibility solutions: 
              <span class="hljs-number">1.</span> dependencies can be managed <span class="hljs-keyword">through</span> <span class="hljs-keyword">the</span> use <span class="hljs-keyword">of</span> a dependency manager tools like poetry <span class="hljs-keyword">or</span> Conda. Additionally, creating requirements.txt <span class="hljs-built_in">file</span> <span class="hljs-keyword">or</span> conda-lock <span class="hljs-built_in">file</span> can be useful. Another type <span class="hljs-keyword">of</span> <span class="hljs-built_in">file</span> commonly used <span class="hljs-keyword">is</span> <span class="hljs-keyword">the</span> environment.yml <span class="hljs-built_in">file</span>. Each <span class="hljs-built_in">file</span> type has <span class="hljs-keyword">its</span> own benefit <span class="hljs-keyword">and</span> place <span class="hljs-keyword">of</span> use.
                  <span class="hljs-number">1.</span> Refer <span class="hljs-keyword">to</span> this <span class="hljs-keyword">for</span> more tools: Dependency <span class="hljs-keyword">and</span> environment management tools <span class="hljs-keyword">for</span> Python 
              <span class="hljs-number">2.</span> Docker <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> create Environment Isolation so <span class="hljs-keyword">that</span> <span class="hljs-keyword">the</span> computer OS <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span> up <span class="hljs-keyword">the</span> same. This <span class="hljs-keyword">is</span> crucial when programs must <span class="hljs-keyword">reference</span> files <span class="hljs-keyword">from</span> your computer, use <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> directory, etc.
          <span class="hljs-number">2.</span> Code Maintenance solutions: 
              <span class="hljs-number">1.</span> People normally used code testing frameworks like unittest <span class="hljs-keyword">for</span> Python <span class="hljs-keyword">to</span> perform unit testing.
              <span class="hljs-number">2.</span> doctest <span class="hljs-keyword">is</span> another module <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> used <span class="hljs-keyword">to</span> perform testing <span class="hljs-keyword">in</span> addition <span class="hljs-keyword">to</span> simultaneous documentation. This should be used <span class="hljs-keyword">in</span> cases <span class="hljs-keyword">where</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">script</span> <span class="hljs-keyword">is</span> rather simple <span class="hljs-keyword">or</span> small. It can involve less work than setting up a unittest framework. However, doctest can be very fickle so <span class="hljs-keyword">it</span> requires close attention <span class="hljs-keyword">to</span> how you code something.
          <span class="hljs-number">3.</span> Code communication solutions:
              <span class="hljs-number">1.</span> People normally use Github <span class="hljs-keyword">for</span> performing source control <span class="hljs-keyword">and</span> <span class="hljs-built_in">version</span> control. This enables people <span class="hljs-keyword">to</span> <span class="hljs-keyword">reference</span> <span class="hljs-keyword">the</span> same ground truth <span class="hljs-keyword">and</span> build off <span class="hljs-keyword">the</span> same thing. <span class="hljs-built_in">version</span> control allows you <span class="hljs-keyword">to</span> make sure <span class="hljs-keyword">that</span> changes are compatible <span class="hljs-keyword">and</span> <span class="hljs-keyword">that</span> they can be tracked <span class="hljs-keyword">and</span> referred <span class="hljs-keyword">to</span>.
              <span class="hljs-number">2.</span> documentation helps a lot <span class="hljs-keyword">with</span> communicating what your code <span class="hljs-keyword">does</span>. This can give a brief explanation <span class="hljs-keyword">to</span> what <span class="hljs-keyword">is</span> happening <span class="hljs-keyword">or</span> why. 
          <span class="hljs-number">4.</span> code comprehension solutions:
              <span class="hljs-number">1.</span> reasoning solutions: 
                  <span class="hljs-number">1.</span> This can be improved <span class="hljs-keyword">by</span> developing familiarity <span class="hljs-keyword">with</span> reading documentation. Reading documentation can be tedious <span class="hljs-keyword">but</span> repeated exposure <span class="hljs-keyword">and</span> <span class="hljs-built_in">application</span> can create fast-thinking frameworks <span class="hljs-keyword">that</span> enable <span class="hljs-keyword">the</span> ability <span class="hljs-keyword">to</span> understand how code works faster. 
                  <span class="hljs-number">2.</span> Look <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> definition <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> variable, function, <span class="hljs-built_in">class</span>, <span class="hljs-keyword">or</span> <span class="hljs-keyword">script</span> <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> being called <span class="hljs-keyword">and</span> see how <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> defined within <span class="hljs-keyword">the</span> codebase. This means trying <span class="hljs-keyword">to</span> see what <span class="hljs-keyword">the</span> object <span class="hljs-keyword">does</span> <span class="hljs-keyword">and</span> how <span class="hljs-keyword">it</span> works <span class="hljs-keyword">by</span> looking <span class="hljs-keyword">at</span> <span class="hljs-keyword">the</span> way <span class="hljs-keyword">that</span> <span class="hljs-keyword">some</span> has created ie. look <span class="hljs-keyword">at</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">the</span> function <span class="hljs-keyword">is</span> defined <span class="hljs-keyword">and</span> <span class="hljs-built_in">read</span> <span class="hljs-keyword">through</span> <span class="hljs-keyword">and</span> understand how <span class="hljs-keyword">it</span> works. VS Code offers an easy way <span class="hljs-keyword">to</span> do this.
                  <span class="hljs-number">3.</span> Find something <span class="hljs-keyword">that</span> <span class="hljs-keyword">is</span> easily understood <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> trace <span class="hljs-keyword">the</span> cognitive steps backwards <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">beginning</span>. Do this multiple <span class="hljs-keyword">times</span> like peeling <span class="hljs-keyword">the</span> layers <span class="hljs-keyword">of</span> an onion. 
                  <span class="hljs-number">4.</span> Find quality examples <span class="hljs-keyword">that</span> provide good exposure <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> principles <span class="hljs-keyword">and</span> assumptions <span class="hljs-keyword">at</span> play. This will force you <span class="hljs-keyword">to</span> integrate <span class="hljs-keyword">the</span> ideas <span class="hljs-keyword">into</span> your mental model. This can be done <span class="hljs-keyword">through</span> intellectus <span class="hljs-keyword">or</span> more rigorously <span class="hljs-keyword">through</span> ratio. intellectus will allow <span class="hljs-keyword">for</span> a fast-thinking model <span class="hljs-keyword">to</span> detect patterns; however, <span class="hljs-keyword">it</span> will create patterns <span class="hljs-keyword">that</span> may <span class="hljs-keyword">or</span> may <span class="hljs-keyword">not</span> be present. 
                  <span class="hljs-number">5.</span> Find CS patterns rather than learning Syntax: Oftentimes, when learning <span class="hljs-keyword">to</span> <span class="hljs-keyword">get</span> started <span class="hljs-keyword">in</span> programming. One has a tendency <span class="hljs-keyword">to</span> imitate <span class="hljs-keyword">and</span> <span class="hljs-keyword">copy</span> <span class="hljs-keyword">the</span> work <span class="hljs-keyword">that</span> has been established <span class="hljs-keyword">before</span>. By learning CS patterns <span class="hljs-keyword">then</span> we can learn principles <span class="hljs-keyword">that</span> can be readily <span class="hljs-keyword">and</span> quickly applied <span class="hljs-keyword">to</span> develop new things. This allows ratio.
              <span class="hljs-number">2.</span> observation solutions: 
                  <span class="hljs-number">1.</span> Practice, Practice, Practice: One should practice regularly <span class="hljs-keyword">and</span> ingest <span class="hljs-keyword">as</span> much hands-<span class="hljs-keyword">on</span> learning <span class="hljs-keyword">as</span> possible <span class="hljs-keyword">to</span> develop experience <span class="hljs-keyword">and</span> familiarity <span class="hljs-keyword">with</span> programming. Otherwise, there <span class="hljs-keyword">is</span> no <span class="hljs-built_in">real</span> understanding <span class="hljs-keyword">of</span> causality <span class="hljs-keyword">and</span> <span class="hljs-keyword">it</span> can lead <span class="hljs-keyword">to</span> faulty mental model. 
                  <span class="hljs-number">2.</span> Experiment <span class="hljs-keyword">with</span> failure: Try <span class="hljs-keyword">to</span> see how something will fail <span class="hljs-keyword">and</span> how <span class="hljs-keyword">it</span> will work based <span class="hljs-keyword">on</span> how you interact <span class="hljs-keyword">with</span> <span class="hljs-keyword">the</span> object. 
                  <span class="hljs-number">3.</span> Find quality examples: This means making sure <span class="hljs-keyword">the</span> examples <span class="hljs-keyword">and</span> practices you observe are quality. Sometimes <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> appropriate <span class="hljs-keyword">to</span> accept <span class="hljs-keyword">or</span> learn a bad practice so <span class="hljs-keyword">that</span> appreciation can be obtained <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> right way.
              <span class="hljs-number">3.</span> Appeal <span class="hljs-keyword">to</span> authority solutions:
                  <span class="hljs-number">1.</span> Don't be afraid <span class="hljs-keyword">to</span> ask online <span class="hljs-keyword">and</span> <span class="hljs-keyword">in</span>-person: The <span class="hljs-keyword">first</span> step <span class="hljs-keyword">to</span> learning <span class="hljs-keyword">is</span> accepting <span class="hljs-keyword">the</span> role <span class="hljs-keyword">of</span> a student <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> next <span class="hljs-keyword">is</span> being a good one. Refer <span class="hljs-keyword">to</span> habits <span class="hljs-keyword">of</span> a good student <span class="hljs-keyword">to</span> see how this applies generally. 
                      <span class="hljs-number">1.</span> Post questions regularly <span class="hljs-keyword">on</span> forms <span class="hljs-keyword">and</span> discussion boards. Resources like Stack Overflow are great <span class="hljs-keyword">for</span> finding solutions <span class="hljs-keyword">while</span> learning something new. Other stack exchange websites can be used <span class="hljs-keyword">as</span> well.
                  <span class="hljs-number">2.</span> Read documentation: This means <span class="hljs-keyword">that</span> you take <span class="hljs-keyword">the</span> <span class="hljs-built_in">time</span> necessary <span class="hljs-keyword">to</span> learn something <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> integrate <span class="hljs-keyword">as</span> part <span class="hljs-keyword">of</span> your mental model <span class="hljs-keyword">for</span> creating a solution.
                  <span class="hljs-number">3.</span> Maintain awareness: This means <span class="hljs-keyword">that</span> you are consistently keeping up <span class="hljs-keyword">with</span> how understanding <span class="hljs-keyword">is</span> being developed <span class="hljs-keyword">and</span> applied throughout <span class="hljs-keyword">the</span> programming community. This means signing up <span class="hljs-keyword">for</span> blogs, email lists, <span class="hljs-keyword">and</span> conferences. They can offer <span class="hljs-keyword">the</span> ability <span class="hljs-keyword">to</span> update who one should appeal <span class="hljs-keyword">to</span> <span class="hljs-keyword">for</span> authority.
      </code></pre>Abstract:</li>
      </ol>
      <p>Outline:</p>
      <p>Essay:
      The goal of this essay is to enable the reader to be able to understand what problems that professional developers, specifically in the context of python developers face. This is for a more general audience as different python developers can varying problems based on their application such as optimization challenges or package management problems. There are more comprehensive ways to cover these and they require a lot of discourse to fully unpack (the unintended pun being that packages are unpacked to have access to their classes, functions, and methods). This essay will cover what problems developers run in the implementation of their ideas into code and the what solutions are used to solve these problems. This is not specific to computer scientists, rather these principles affect all people who perform technical work in the coming years as programming proficiency has developed into an almost universal requirement for any STEM disciplines. </p>
      <p>The problems that people run into programming generally is code reproducibility, Code Maintenance, Code communication, and code comprehension. The solutions are then applied to these categories based on popularity, ease of use, and applicability. First, code reproducibility problems occur when someone tries to hand another person code and they are not able to set your computer up like theirs. Second, Code Maintenance problems occur when code must be utilized over a period of time outside of immediate use which leads to the problems of making sure the infrastructure still supports the operation of your code. This is especially relevant after some code needs to reconfigured to operate a different way or have additional functionality. </p>
      <blockquote>
      <p>Note: that code reproducibility and Code Maintenance are very closely linked which is why it is important that great care is taken in making sure that programs are developed in well organized environments almost like lab experiments. </p>
      </blockquote>
      <p>Third, Code communication is when more than one person is working on code then how do you make sure that your change won&#39;t screw up the codebase. Consider the fact that multiple people may be working on different functions that are going to placed in the same document. How can you make sure that the solution that you&#39;ve made still works? Fourth and lastly, code comprehension problems occur when people are unable to understand the code they are presented because it is too complex, foreign, or proper documentation is not available. </p>
      <p>code reproducibility in the modern world involves using dependencies. This is simply a fact that one must accept since the code you develop will always rely on some other part that must be trusted and understood to whatever degree the application requires. Fortunately, this problem can be documented such that similar to citing you sources; you can specify your dependencies so others can analyze and recreate your work. The issue with code reproducibility is version control for dependencies which is an important problem that requires the use of solutions like package management tools like poetry and Conda for Python. Understanding how to set up and implement dependency management tools and environment management for Python is a topic that can be addressed in a separate article. The second code reproducibility issue is managing environment variable which is crucial for SSH scripting. This is particularly important for a language like Python which has a fair bit of interaction with the CLI (Command Line Interface). The CLI is used to How to start up conda environments|start up conda environments, how to activate package scripts|activate package scripts like Sphinx package (a documentation generator for Python) or poetry for package management. Using tools like Docker can alleviate this problem since it creates a containerization|container that will utilize all the same OS processes as your computer; however, it will create a completely new Unix style file directory and environment variables list. The third issue is file directory setup which is solved by Docker. This means that the way your file explorer or finder app shows your computers file directory is the same. Having a standard file directory is a big problem when your program is trying to figure out what it is running on and use dependencies and information from that computer to run well. Consider where the program should store data or what if it references another file. If you open up Steam then it shows all the games you have, but what if you move the files for your games somewhere else around the computer then it will not be able to find it. You could probably trick your computer by replacing a file with a black file that has the same name and changing the name of the original file. This is a surefire way to have many problems stop working. This assumption that I can find files and data around your computer is crucial for complex problems that involve user interaction. Consider the environment variables list mentioned earlier. This list must be stored somewhere and depending on your OS the location may be different. </p>
      <p>Code Maintenance is another major issue that some would argue would fall under reproducibility though I focused more on how the code needs to be maintained over time when changes are made or it is modified. Unfortunately, code is similar to a house blueprint where you can modify the drawing after it is finished but then it may affect other parts in ways that you don&#39;t expect. 
      Consider the following two images:
      !Pasted image 20240202123539.png
      !Pasted image 20240202123719.png
      When you add a mustache to the Mona Lisa the have made the picture less cohesive and this can clutter up as you manipulate a program beyond it&#39;s designed functionality. This should be balanced with the DRY principle which says &quot;Don&#39;t Repeat Yourself&quot; ie. try to abstract ideas that repeatedly used into little pieces that you can reuse over an over when you need. This doesn&#39;t mean you turn everything into a perfect pieces. Rather, find stuff that you are doing in a tedious and repetitive way and see if programming it saves you any time. Many times its easier to let it go and not program unless you enjoy it. Creating well maintained, reusable code is a way to make your life easier in the future, especially if the code will be used often or flexibly. Enough justification about Code Maintenance, now it&#39;s time explain some of the types of problems and how they are solved.  The main problems that developers face in Code Maintenance is Code Abstraction, code refactorization, and code testing. These three problems are found in the fact that making general solutions to programming problems is hard and oftentimes it&#39;s easy to hardcode or pile things up into one file rather than abstract code into something general. Code Abstraction is when you try to develop abstract representations of your code such as putting a set of commands into a function, class, or script. This means that whenever a set of code does some set of commands then it should be turned into a function. That function can then placed into larger functions such that a more complex feature is executed. Another approach is to use class and then attach methods so that if you have a class then it will contain all the stuff it needs to operate. Have a set of classes then you can put them together into a larger class that will contain all those functions and whatever else it needs. Code Modularity is a concept that allows you to tuck away the details and trust that the solution works when you apply it. Then the only work is about how you use your newly made tool. If you are making a script then that script should do one thing well and if you need to do multiple things then make another and then import both scripts into a common script where they can be used. Code refactorization is also important for maintenance because it means that clean up the code that you&#39;ve written to make sure that it is simple, professional, and elegant. Oftentimes this means that you make rewrite an object so that it is easier to understand when you hand it to someone else or try to write documentation for it. This may mean splitting things up so that they are more general and act more like Lego blocks than welded parts. Refactor means that code is adjusted to work more flexibly while still retaining its intended functionality. Note: this may involve taking a less optimized approach that it more understand and more flexible while understanding the limitations of the code. Code testing is a major point that I want to harp on because it is not talked about enough in teaching python. This is when you implement tests/logic to make sure that your code is robust and you can figure out what went wrong if your code doesn&#39;t work right. This solves a debugging problem by giving diagnostics about what failed and why when you test a software application. unit testing is a specific tool that has been transformed into a methodology called Test-Driven Development. The idea is that you can create simple tests that will tell you if your code is operating the way you want by seeing if the results you pass are as expected or if they are different. This is useful when your code has bugs that don&#39;t result in errors so you end up with a software that is telling you false information that is assumed to be right. 
          <code>X = 1</code>
          <code>y = x + x</code>
          `y = 1000
      integration testing helps to make sure that when various pieces of code, imported modules, and called services all work together as expected. Note that pieces of code, modules, and services can operate without error while still delivering faulty, buggy results. These are more computer intensive than unit tests since it means that various parts of the code will be initialized and then tested. This is crucial for making sure that your code works the way it is supposed to with other code. This only tests whether the pieces work together not if they work together well. Functional testing is testing to focus on how the software accomplishes the business requirements that it was designed to accomplish. If a search app was designed then this kind of testing determine whether people can effectively search from a business or use perspective to accomplish the requirement of enabling people to search effectively. This tests to see if pieces work together well and correctly. End-to-end testing is to test specific use cases that would imitate a user trying to perform some action that is often more complex than simply testing functionality. These kinds of tests are useful but hard to maintain and should not be relied on since this changes often and it hard to develop without existing test infrastructure.</p>
      <p>The third major problem that developers face is Code communication which is when more than one person is working on code but everyone has to understand what is happening. The question is then how do you make sure that your change won&#39;t screw up the codebase? Consider the fact that multiple people may be working on different functions that are going to placed in the same document. How can you make sure that the solution that you&#39;ve made still works? By using source control and version control like Github, we can solve this problem. source control is important to make sure that the foundation multiple people are building on stays the same. Consider a team of architects decides to work with contractors to build a house. If one architect goes in the middle of the night and changes the plans then this may affect whether the solutions that other architects made will apply. Additionally, the contractors will have to completely redo their work since their solution may no longer be valid. If changes are understood and agreed upon by the entire team then this problem can be averted. This is done by having people copies of an agreed upon assumption/framework and then putting their solution on top. The various solutions are combined and then any errors that result can be resolved though this should be minimal in an ideal case. Another problem is versioning because people may not know what the latest code is. By implementing a versioning tool, people can ensure that they have the latest setup and along with knowing how changes were implemented over various iterations. </p>
      <p>The last major problem that developers face is code comprehension. This is common because people often jump to asking ChatGPT or searching Stack Overflow for the answer rather than deducing the answer on their own. This can save time but it comes at the expense of understanding and exercise of intellectual faculties which need to be tested and stressed constantly so that we can grow. The first symptom of this is poor documentation. Documentation is crucial for making sure that people can understand your code if they want to go back and understand. Good code is something that people love to go back and use, including yourself. Consider the library OpenCV which has a famously amazing documentation which can walk anyone through how to do object recognition. Below I&#39;ve listed the various kids of documentation. I would recommend looking up some examples. I hope to update this essay with my own example someday.</p>
      <ol>
      <li>one-liner documentation : This is when you just put small comments next to your statements to help elucidate what the goal of your command is. This can help you think through what you want to do along with guiding others.</li>
      <li>function-level documentation: This is documentation that is placed at the top of a series of one-liners. It explains what the overall goal of the following commands is as well as how to use the function. The function can be implemented as a one-liner documentation  so we want to understand how to use the function easily but don&#39;t want to read through the details of what happens. </li>
      <li>class-level documentation: This is documentation that explains what the set of functions/methods is designed to do and what the goal of this collection of functions/methods is. It also explains what the initialization of this class does and how to use it. This should be a higher level description than a compilation of function-level documentation. It should explain how to use the class and the available functions with brief descriptions of what they are for and how to use them.</li>
      <li>script-level documentation: This is documentation that is designed to explain what the point of the script/library is. This is a high level view of what the code module does and it explains any classes, script-level functions, and script-wide parameters. This allows someone who calls the module into another document to understand what functionality they can gain and what tools are available to do so. This can be something with a summary followed by a fairly lengthy detailed description that shows what the code can do on a functional, goal-oriented level.
      reasoning: This means applying logic and understanding the cognitive train of thought that it involved with getting from one set of information or assumptions to a conclusion. Reasoning often occurs in a passive sense and it is something that we do fast-thinking; however, something reasoning involves slow-thinking. We can use models to simplify the logical sequence of steps that must be taken to understand a conclusion. This is often expensive to do in reality and it may not be feasible with additional time or cognitive constraints. This can be improved by developing familiarity with reading documentation. Reading documentation can be tedious but repeated exposure and application can create fast-thinking frameworks that enable the ability to understand how code works faster. Additionally, looking at the definition of the variable, function, class, or script that is being called and see how it is defined within the codebase. This means trying to see what the object does and how it works by looking at the way that some has created ie. look at where the function is defined and read through and understand how it works. VS Code offers an easy way to do this through peeking or simply going to the object definition. Another way to reason through code and understand it is to find something that is easily understood and then trace the cognitive steps backwards to the beginning. Do this multiple times like peeling the layers of an onion. Third, find quality examples that provide good exposure to the principles and assumptions at play. This will force you to integrate the ideas into your mental model. This can be done through intellectus or more rigorously through ratio. intellectus will allow for a fast-thinking model to detect patterns; however, it will create patterns that may or may not be present. Last is to find CS patterns rather than learning Syntax: Oftentimes, when learning to get started in programming. One has a tendency to imitate and copy the work that has been established before. By learning CS patterns then we can learn principles that can be readily and quickly applied to develop new things. This allows ratio.
      Another way that code comprehension fails it that people don&#39;t practice by doing and playing. Observation/contemplation is when we simply see the code running and we look at the outputs and see what happens when the program is run. It doesn&#39;t imply that you have strong deductive knowledge about how the program works only that you know how to use it. The use of observation allows us to gain knowledge that the experts have and use, but are unable to convey as a result of hidden assumptions. Exposing these hidden assumptions consciously takes a lot of work and therefore it may be easier to implement a habit of observation. This is what happens in art. Try implementing some of the solutions below:    !Pasted image 20240201000003.png</li>
      <li>Practice, Practice, Practice: One should practice regularly and ingest as much hands-on learning as possible to develop experience and familiarity with programming. Otherwise, there is no real understanding of causality and it can lead to faulty mental model. </li>
      <li>Experiment with failure: Try to see how something will fail and how it will work based on how you interact with the object. </li>
      <li>Find quality examples: This means making sure the examples and practices you observe are quality. Sometimes it is appropriate to accept or learn a bad practice so that appreciation can be obtained for the right way.</li>
      </ol>
      <p>Lastly code comprehension fails because people don&#39;t take the time to find help and appeal to authority. This is when you consult a trusted person or resource like Stack Overflow to determine what is happening. This can also be through reading through the documentation for any functions which is almost always available. Don&#39;t be afraid to ask online and in-person: The first step to learning is accepting the role of a student and then next is being a good one. One tip is to post questions regularly on forms and discussion boards. Resources like Stack Overflow are great for finding solutions while learning something new. Other stack exchange websites can be used as well. Second, read documentation. This means that you take the time necessary to learn something and then integrate as part of your mental model for creating a solution. Third, is to maintain awareness by consistently keeping up with how understanding is being developed and applied throughout the programming community. This means signing up for blogs, email lists, and conferences. They can offer the ability to update who one should appeal to for authority.</p>
    </div>
  </body>
</html>